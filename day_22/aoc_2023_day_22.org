
* AOC 2023 Day 22

** Initialize 
#+BEGIN_SRC elisp
  (pyvenv-activate "~/projects/project_venv/")
  ; This is needed to make sure python indentation isn't messed up
  (setq org-src-preserve-indentation t)
#+END_SRC

#+RESULTS:
: t

** Day 22 star 1
*** Solution
#+BEGIN_SRC python :results output
import re
from d22_utils import Grid, P,S,dump_grid_x, dump_grid_y
from pydantic import BaseModel

def p_from_a(a: list):
    return P(x=int(a[0]),y=int(a[1]),z=int(a[2]))

class Brick(BaseModel):
    a: P
    b: P
    n: int
    
    def add(self,grid: Grid):
        for x in range(self.a.x, self.b.x+1):
            for y in range(self.a.y,self.b.y+1):
                for z in range(self.a.z, self.b.z+1):
                    grid.cells[P(x=x,y=y,z=z)] = self.n

    def remove(self,grid: Grid):
        for x in range(self.a.x, self.b.x+1):
            for y in range(self.a.y,self.b.y+1):
                for z in range(self.a.z, self.b.z+1):
                    grid.cells[P(x=x,y=y,z=z)] = None

    def resting_on(self,grid: Grid) -> set:
        touching = set()
        min_z = min(self.a.z, self.b.z)
        for x in range(self.a.x, self.b.x+1):
            for y in range(self.a.y, self.b.y+1):
                t = grid.cells.get(P(x=x,y=y,z=min_z-1))
                if t and t != self.n:
                    touching.add(t)

        return touching

    def drop(self, grid: Grid) -> bool:
        min_z = min(self.a.z, self.b.z)
        moved = False
        
        if min_z > 1:
            self.remove(grid)
            while min_z > 1 and not self.resting_on(grid):
                self.a.z-=1
                self.b.z-=1
                moved = True
                min_z = min(self.a.z, self.b.z)
            self.add(grid)
             
        return moved

def star_1(path: str,debug=False) -> int:
  with open(path,'r') as f:
      bricks = []
      m = P()
      n = 1
      for l in f.read().split("\n"):
          if l:
              a,b = l.strip().split("~")
              brick = Brick(n=n, a=p_from_a(a.split(",")),b=p_from_a(b.split(",")))
              bricks.append(brick)
              if brick.a.x > m.x: m.x = brick.a.x
              if brick.b.x > m.x: m.x = brick.b.x
              if brick.a.y > m.y: m.y = brick.a.y
              if brick.b.y > m.y: m.y = brick.b.y
              if brick.a.z > m.z: m.z = brick.a.z
              if brick.b.z > m.z: m.z = brick.b.z
              n+=1
      grid = Grid(cells={},size=S(width=m.x+1, height=m.y+1, depth=m.z+1), blocked=[])
      for brick in bricks:
         brick.add(grid)

      if debug:
          print("-- Before drop --")
          print(" x ")
          print("012")
          dump_grid_x(grid)
      
          print(" y ")
          print("012")
          dump_grid_y(grid)

      moved = True
      i = 0
      while moved:
          i+=1
          moved = False
          for brick in bricks:
              if brick.drop(grid):
                  moved = True

      if debug:
          print("-- After drop --")
          print(" x ")
          print("012")
          dump_grid_x(grid)
          print(" y ")
          print("012")
          dump_grid_y(grid)

      supports = {brick.n: [] for brick in bricks}
      supported = {brick.n: [] for brick in bricks}
      
      for brick in bricks:
          for b in list(brick.resting_on(grid)):
              supports[b].append(brick.n)
              supported[brick.n].append(b)

      removeable = {}
      for brick in bricks:
          can_remove = True
          for sb in supports[brick.n]:
              can_remove=False
              if len([x for x in supported[sb] if x != brick.n]):
                  #print(f"....{sb} supported by other brick {b}")
                  can_remove= True
                  break
          if can_remove:
              removeable[brick.n] = True

      if debug:
          for brick in bricks:
              if removeable.get(brick.n):
                  print(f"Brick {chr(brick.n+64)} can be removed.")
              else:
                  print(f"Brick {chr(brick.n+64)} cannot be removed.")
      
  return len(removeable)
  

print("Star 1:",star_1("input.txt"))

#+END_SRC

#+RESULTS:

** Too high
: Star 1: 612

** Day 22 star 2
*** Problem statement
*** Solution
#+BEGIN_SRC python :results output
def star_2(path: str) -> int:
  with open(path,'r') as f:
     pass
  return 0
  
print("Star 2:", star_2("sample.txt"))
#+END_SRC

