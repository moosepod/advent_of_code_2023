
* AOC 2023 Day 23

** Initialize 
#+BEGIN_SRC elisp
  (pyvenv-activate "~/projects/project_venv/")
  ; This is needed to make sure python indentation isn't messed up
  (setq org-src-preserve-indentation t)
#+END_SRC

#+RESULTS:
: t

** Day 23 star 1
*** Solution
#+BEGIN_SRC python :results output
from pydantic import BaseModel
import re
from d23_utils import P,Grid, dump_grid,S, UP,DOWN,LEFT,RIGHT,PriorityQueue

class Vertex(BaseModel):
    p: P
    c: str
    edges: list["Vertex"]

    def __lt__(self,v):
        return v.p.x < self.p.x and v.p.y < self.p.y

    def __hash__(self):
        return hash(f"{self.p.x}-{self.p.y}")

def path_from_dict( came_from: dict, end: P) -> list[P]:
    p = end
    path = []
    while p:
        path.append(came_from[p])
        p = came_from[p]

    return path

def pathfind_d(graph: dict[P,Vertex], start: P, end: P) -> list[P]:
    frontier = PriorityQueue()
    frontier.put(graph.get(start), 0)
    came_from = {start: None}
    cost_so_far = {start: 0}

    while not frontier.empty():
        current = frontier.get()

        if current.p == end:
            return path_from_dict(came_from, end)

        for n in current.edges:
            new_cost = cost_so_far[current.p] + 1
            if n not in cost_so_far or new_cost > cost_so_far[n]:
                cost_so_far[n] = new_cost
                frontier.put(graph.get(n), new_cost)
                came_from[n] = current.p

    return []

def follow_to_node(graph: dict[P,Vertex], start: P, end: P) -> list[P]:
    v = start
    path = [start]
    while len(graph[v].edges) < 3 and v != end:
        for edge in graph[v].edges:
            if edge not in path:
                path.append(edge)
                v = graph[edge].p

    return path

def pathfind(graph: dict[P,Vertex], start: P, end: P, current_path: [], all_paths: [],indent=0):
    candidates = PriorityQueue()
    candidates.put(start, 0)
    #visited = set()
    paths = {start: []}
    
    while not candidates.empty():
        print()
        current = candidates.get()        
        for edge in graph[current].edges:
            if edge not in paths.get(current):
                print(current,edge)

                next_path = [x for x in paths.get(current)]
                next_path.extend(follow_to_node(graph, edge, end))
                path_end = next_path[-1]
                paths[path_end] = next_path
                if path_end == end:
                    all_paths.append(next_path)
                else:
                    candidates.put(path_end,0)
    
    
def star_1(path: str) -> int:
  with open(path,'r') as f:
      graph: dict[P,Vertex] = {}
      nodes: list[Vertex] = []
      s = S(width=0,height=0)
      for y, line in enumerate(f.read().split("\n")):
          s.height += 1
          if line:
              if not s.width:
                  s.width = len(line)
              for x,c in enumerate(line):
                  if c != '#':
                      p = P(x=x,y=y)
                      graph[p] = Vertex(p=p,edges=[],c=c)

      for v in graph.values():
          if v.c == ">": v.edges.append(v.p + RIGHT)
          if v.c == "<": v.edges.append(v.p + LEFT)
          if v.c == "^": v.edges.append(v.p + UP)
          if v.c == "v": v.edges.append(v.p + DOWN)
          if v.c == ".":
              if graph.get(v.p+UP): v.edges.append(v.p+UP)
              if graph.get(v.p+DOWN): v.edges.append(v.p+DOWN)
              if graph.get(v.p+LEFT): v.edges.append(v.p+LEFT)
              if graph.get(v.p+RIGHT): v.edges.append(v.p+RIGHT)
          if len(v.edges) > 2:
              nodes.append(v)

      start = P(x=1,y=0)
      end = P(x=21,y=22)
      
      debug_grid = Grid(cells={},size=s,blocked=[])
      for p in debug_grid.points():
          if graph.get(p):
              debug_grid.cells[p] = graph[p].c
          else:
              debug_grid.cells[p] = "#"

      all_paths = []
      pathfind(graph, start, end, [], all_paths)
      for path in all_paths:
          print(len(path))
      return 0
          
      #path = {p: "O" for p in pathfind(graph, start, end, [])}
      p1 = follow_to_node(graph,start,end)
      path = {p: "O" for p in p1}
      path.update({p: "O" for p in follow_to_node(graph,p1[-1]+DOWN,end)})

      dump_grid(debug_grid,path)

  return len(nodes)
  


print("Star 1:",star_1("sample.txt"))

#+END_SRC

#+RESULTS:
#+begin_example

x=1 y=0 z=0 x=1 y=1 z=0

x=3 y=5 z=0 x=3 y=6 z=0
x=3 y=5 z=0 x=4 y=5 z=0

x=11 y=3 z=0 x=11 y=4 z=0
x=11 y=3 z=0 x=12 y=3 z=0

x=21 y=11 z=0 x=21 y=12 z=0
x=21 y=11 z=0 x=20 y=11 z=0

x=21 y=11 z=0 x=21 y=12 z=0

x=5 y=13 z=0 x=5 y=14 z=0
x=5 y=13 z=0 x=6 y=13 z=0

x=13 y=13 z=0 x=13 y=12 z=0
x=13 y=13 z=0 x=13 y=14 z=0
x=13 y=13 z=0 x=14 y=13 z=0

x=21 y=11 z=0 x=21 y=10 z=0
x=21 y=11 z=0 x=21 y=12 z=0

x=21 y=11 z=0 x=21 y=12 z=0

x=13 y=13 z=0 x=13 y=14 z=0
x=13 y=13 z=0 x=14 y=13 z=0

x=21 y=11 z=0 x=21 y=10 z=0
x=21 y=11 z=0 x=21 y=12 z=0

x=21 y=11 z=0 x=21 y=12 z=0

x=13 y=13 z=0 x=13 y=14 z=0
x=13 y=13 z=0 x=14 y=13 z=0

x=21 y=11 z=0 x=21 y=10 z=0
x=21 y=11 z=0 x=21 y=12 z=0

x=21 y=11 z=0 x=21 y=12 z=0

x=13 y=19 z=0 x=12 y=19 z=0
x=13 y=19 z=0 x=14 y=19 z=0

x=13 y=19 z=0 x=14 y=19 z=0

x=13 y=19 z=0 x=14 y=19 z=0

x=13 y=19 z=0 x=14 y=19 z=0

x=13 y=19 z=0 x=14 y=19 z=0

x=19 y=19 z=0 x=19 y=18 z=0
x=19 y=19 z=0 x=19 y=20 z=0

x=19 y=19 z=0 x=19 y=20 z=0

x=19 y=19 z=0 x=19 y=20 z=0

x=19 y=19 z=0 x=19 y=20 z=0

x=19 y=19 z=0 x=19 y=20 z=0

x=19 y=19 z=0 x=19 y=20 z=0

x=19 y=19 z=0 x=19 y=20 z=0

x=19 y=19 z=0 x=19 y=20 z=0

x=19 y=19 z=0 x=19 y=20 z=0

x=19 y=19 z=0 x=19 y=20 z=0

x=19 y=19 z=0 x=19 y=20 z=0

x=19 y=19 z=0 x=19 y=20 z=0

x=19 y=19 z=0 x=19 y=20 z=0

x=19 y=19 z=0 x=19 y=20 z=0
81
81
81
81
81
81
81
81
81
81
81
81
81
81
Star 1: 0
#+end_example

